https://stdbc.tistory.com/59?category=876330

https://jaeseokim.github.io/C/42Seoul-ft_printf-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B8%B0%EB%A1%9D/



* All heap allocated memory space must be properly freed when necessary. No leaks will be tolerated.

(필요한 경우 모든 힙 할당 메모리 공간을 적절하게 해제해야한다. 메모리 누출은 안된다.)

















`%[플래그(flag)][폭(width)][.정밀도][크기(length)]서식 문자(specifier)`



```swift
https://nomad-programmer.tistory.com/104
*.a file 에 관하여
gcc main.c -L/Users/yujun-yong/Desktop/ft_printf -lftprintf -o test

현재경로이면 옵션을 -L./
```



# 가변인자 (Variadic Arguments)









https://velog.io/@meong9090/ftprintf-%EA%B3%A0%ED%86%B5%EC%9D%98-%ED%94%84%EB%A6%B0%ED%8A%B8%EC%97%90%ED%94%84%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90









### 1. Printf() 함수의 매개변수 

`printf("%d * %d = %d", 3, 5, 3*5);`

printf 함수는 위 코드와 같이, 가변인자의 개수를 사용자 마음대로 바꾸어도 문제없이 잘 작동한다.

이것은 가변인자 덕분에 가능하다.



### 2. 가변인자 

`...`이 가변인자 혹은 가변 파라미터라고 불린다.

매개변수로 아무것도 넘겨주지 않을 수도 있고, 혹은 여러개로 넘겨주어도 된다.

이러한 매크로는 함수가 고정된 수의 필수인수에 가변 수의 선택적 인수가 붙은 형식을 사용한다고 가정한다.







<hr>

<hr>

### 형식패턴에 따른 값의 변화

* 플래그
* 폭
* 정밀도



## 플래그

* 기본적인 플래그는 "-0", 보너스는 "# +"(가운데는 공백)
* 기본 플래그 + 보너스 플래그는 중복이 가능하지만, 기본 플래그+ 기본플래그의 중복 및 보너스 플래그 + 보너스 플래그 중복은 무시되거나 작동이 안된다.



### '-'

* 모든 서식문자에 동일하게 적용된다.
* width와 함께 작동하고, 좌측 정렬로 출력하라는 뜻이 된다.

```c
printf("%-5d", 123);
>>> "123  "
```



### '0'

* width로 인해 출력되는 공백을 0으로 채워서 출력한다.

```c
printf("%05d", 123);
>>>"00123"
```



* '-' 와 '0' 플래그가 중복된다면, '0'이 무시된다.

```c
printf("%-05d", 123);
>>> "123  "
```



* 정밀도가 있다면 플래그 '0'이 무시된다.

```c
printf("%05.d", 1);
>>> "    1"
```



### '#'

* 플래그 정수를 16진수로 출력하는 x, X값 앞에 각각 0x, 0X를 붙여주는 플래그이다.

```c
printf("%#Xx, 123");
>>> "0x7b"
```



* 기본플래그와 중복해서 사용이 가능하다.

```c
printf("%0#5X", 123);
>>> "0X07b"
```





### ' '(공백)

* 정수 앞에 기호가 붙지 않는다면, 공백을 한칸 출력해준다.

```c
printf("% d", 123);
>>> " 123"
```



* 기본플래그와 중복이 가능하다.

```c
printf("%0 5d", 123);
>>> " 0123"
```



### '+'

* 양수에도 부호를 붙여서 출력해준다  (음수는 원래 붙여서 나오니까)

```c
printf("%+d", 123);
>>> "+123"
```



* 기본 플래그와 중복이 가능하다.

```c
printf("%0+5d", 123);
>>> "+0123"
```





## 폭(width)



* 폭은 출력할 문자열의 총 길이의 최소값을 지정해서 출력한다.

```c
printf("%5d", 123); // 폭은 5, 출력할 길이는 3이다. 따라서 남는 2는 공백으로 채워서 출력된다.
"  123"
```

```c
printf("%2d", 123) // 출력할 길이는 3인데, 폭을 2로 했다. 이러한 경우에는 폭이 무시가된다.
  >>> "123"
```



* 폭의 우선순위가 가장 낮다. 플래그, 출력 값, 정밀도 등 모든 값들이 출력 된 후에도 남은 폭이 있다면 그때 공백으로 채워지는 방식이다.
* 값을 가변인자로 받아 올 수 있다. 그럴땐 정수가 아니라 '*'을 사용한다.

```c
printf("%*d, 5, 123");
"  123"
```

* 0이상의 값이 올 수 있다. 플래그 '0'과 혼동하면 안된다.

```c
printf("%00d"); // 이러한 경우가 아니라면, 0은 폭이 아니라 플래그 '0'이다.
```







## 정밀도 (precision)

* 정수와 함께 사용하면, 폭과 비슷하게 출력의 최소값이 정해지는데, 폭은 모든 값에 영향을 받지만 정밀도는 서식문자에만 영향을 준다. 폭은 공백을 채워 출력하지만, 정밀도는 '0'을 채워넣어 출력한다.



```c
printf("%.5d, %+.5d", 123)
>>> "00123,  +00123"
```

* 정밀도는 항상 '.'뒤에 나오고, '.'만 사용할 수도 있다.

```c
printf("%5.5d, %5.d", 123, 123);
"00123,   123"
```

* 서식문자 %c는 정밀도의 영향을 받지 않는다.
* 서식문자 %s는 정밀도의 영향을 다르게 받는다. 정수에서는 최소값이었다면, %s에서는 최대값이라고 생각하면 도리것같아요??????????

```c
printf("%.2s, %.0s", "123")
>>> "12, "
```













# 서식문자의 예외처리

* # 1. %c

  - c는 크게 어려운 부분이 없이 구현하면 되는데 한 가지만 알아둬야 합니다. 출력 값이 '\0'이 넘어와도 출력을 하고 카운트를 해야합니다.
    물론 그냥 출력하면 되지만 저는 서식문자의 출력값을 모두 문자열로 만든 뒤 하나의 함수로 모든 서식문자를 출력했다보니 출력이 안돼서 직접 출력을 해 줬어야 했습니다.

  ```c
   write(1, info->variable, ft_strlen(info->variable)); // 내가 출력한 방식
  ```

  만약 저 처럼 모든 서식문자의 출력을 하나의 함수에서 출력한다면 따로 처리를 해 주세요!
  그렇지 않고 그냥 각 서식문자마다 개별적으로 출력한다면 크게 신경쓰지 않아도 되는 부분인 것 같으니 알고만 넘어가면 될 것 같습니다.

  # 2. %s

  - 이전 정밀도 부분에서 말했 듯 정밀도에 따라서 값이 덜 출력될 수 있습니다.
    ex) printf("%.2s, %.0s", "123");

  ```c
   "12, "
  ```

  - 만약 NULL포인터가 넘어왔다면 (null)을 출력해 줘야합니다.
    물론 이 문자열 "(null)"도 정밀도의 영향을 받구요.

  # 3. %p

  - 포인터는 크게 주의할 점은 없는데 만약 itoa_base에서 매개변수로 int를 받으면 값이 잘못 출력될 수 있습니다. 포인터의 크기는 각 운영체제 및 환경에 따라 다른데 sizeof로 출력을 해 보면 32비트는 4byte, 64비트 운영체제는 8byte가 나올 거에요. 그렇기 때문에 저는 size_t를 사용했습니다.
  - NULL포인터가 나온다면 0x0을 출력해 주어야 합니다. 이 부분도 별로 중요하진 않아서 구현할 때 알아두기만 한다면 될 것같아요.

  # 4. %d, %i

  - 정밀도가 0일때 정수 서식문자 출력값이 0이면 출력하지 않습니다.
    ex) printf("%.0d", 0);
  - 정수는 #을 제외하고 모든 플래그가 적용이 가능하기에 출력을 할 때 고려해야할 부분이 많아요. 이 부분은 구현할 때 출력을 어떤 방식으로 하느냐에 따라 다르기에 printf함수와 비교를 많이 해 보면서 하길 추천합니다.
    이 서식문자 구현하는게 가장 복잡해요...

  # 5. %u

  - %d, %i만 먼저 구현한다면 큰 어려움 없이 출력이 가능합니다.

  # 6. %x, %X

  - 출력값이 0일 때 보너스플래그 '#'은 적용되지 않습니다.
    ex) printf("%#x, %#x", 1, 0);

  ```c
  "0x1, 0"
  ```

  > #### 사실 %d, %i 출력부분만 구현을 했다면 다른 녀석들은 큰 무리가 없이 구현이 가능하기 때문에 %d, %i먼저 합시다..!

































